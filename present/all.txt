
import path from 'path'
import fs from 'fs'

export function getBaseJS(__systemDir, liveBool) {
    if (__systemDir == null) { // Live server live reload for 404 status
        return fs.readFileSync(path.join(__systemDir, 'live.js'), 'utf-8')
    }
    let jsArr = [
        fs.readFileSync(path.join(__systemDir, 'state.js'), 'utf-8'),
        fs.readFileSync(path.join(__systemDir, 'store.js'), 'utf-8'),
    ];
    if (liveBool) {
        jsArr.push(fs.readFileSync(path.join(__systemDir, 'live.js'), 'utf-8'));
    }
    return jsArr.join("\n");
}

export function getBaseHeadHTML(__systemDir) {
    let htmlArr = [
        fs.readFileSync(path.join(__systemDir, 'meta.html'), 'utf-8'),
    ];
    return htmlArr.join("\n");
}

export function getBaseCSS(__systemDir) {
    let cssArr = [
        fs.readFileSync(path.join(__systemDir, 'structures.css'), 'utf-8'),
    ];
    return cssArr.join("\n");
}

// Main compiler class
export class View {
    filePath = "" // main file path for file
    srcDir = null // directory for FS reading
    rawStr = "" // raw and unprocessed string of code
    rawStrSplit = [] // array of code split by line
    currentLineIndex = 0 // current position within rawLineSplit
    lineOffset = 0 // necessary because of closes
    customStructs = {} // defined structure library
    head = [] // Main HTML Head
    endHtml = [] // End HTML
    html = [] // Main HTML Body
    js = [] // Main JS Store
    css = [] // Main CSS Store

    // Takes in file content
    constructor(txt, callback, directory) {
        this.rawStr = txt
        this.srcDir = directory
        this.compile(DOM => {
            if (callback) callback(DOM)
        })
    }

    // Splits raw code and processes each line
    compile(callback) {
        this.rawStrSplit = this.rawStr.split("\n")

        for (let i = 0; i < this.rawStrSplit.length + this.lineOffset; i++) {
            let currentLine = this.rawStrSplit[this.currentLineIndex]
            if (currentLine == undefined) break
            this.processLine(currentLine)
            this.currentLineIndex++
        }

        callback({
            head: this.head.join("\n"), 
            html: this.html.join("\n"), 
            endHtml: this.endHtml.join("\n"),
            js: this.js.join("\n"),
            css: this.css.join("\n"), 
        })
    }

    // Processes and understands 1 line at a time
    processLine(line) {
        line = line.toString()?.trim()
        let lineSplit = line?.split(" ")
        let firstKey = lineSplit[0]?.trim()
        let secondKey = lineSplit[1]?.trim()
        let thirdKey = lineSplit[2]?.trim()

        // Custom Javascript
        if (firstKey == "{") {
            let contents = []
            let ignoreLineCount = 0
            for (let i = this.currentLineIndex + 1; i < this.rawStrSplit.length; i++) {
                ignoreLineCount++
                let line = this.rawStrSplit[i]?.trim()
                if (line == "}" && this.rawStrSplit[i]?.match(/^\s*/)[0].length == 0) {
                    break
                }
                contents.push(line)
            }
            this.js.push(contents.join("\n"))
            this.currentLineIndex += ignoreLineCount
        }
        // Call Structure
        else if (/^[A-Z]/.test(firstKey)) {
            if (Object.keys(this.structures).includes(firstKey.replace(":", ""))) {
                this.structures[firstKey.replace(":", "")](line)
            }
            else {
                this.structures?.["Custom Structure"](line)
            }
        }
        // Declare Structure
        else if (firstKey == "[]") {
            this.structures?.["Declare Structure"](line)
        }
        // Define Style Class
        else if (firstKey[0] == ".") {
            this.css.push(`${line?.trim()} { ${this.gatherAttributes()} }`)
        }
        // Close Div
        else if (firstKey == "/div") {
            this.html.push("</div>")
        }
        // Close Div
        else if (firstKey == "/span") {
            this.html.push("</span>")
        }
        // Close CSS
        else if (firstKey == "/css") {
            this.css.push("}")
        }
        // Custom HTML
        else if (firstKey == ">>>") {
            this.html.push(line.replace(">>>", "")[1])
        }
    }

    // Collects all proceeding attributes for structs
    gatherAttributes(rawReponseBool) {
        let attrStr = ""
        let styleVal = ""
        let callAlt = this.rawStrSplit[this.currentLineIndex]?.match(/^\s*/)[0].length
        let attrAlt = this.rawStrSplit[this.currentLineIndex + 1]?.match(/^\s*/)[0].length
        for (let i = this.currentLineIndex + 1; i < this.rawStrSplit.length; i++) {
            let currAlr = this.rawStrSplit[i]?.match(/^\s*/)[0].length
            let line = this.rawStrSplit[i].trim()
            let key = line.split(":")[0]?.trim()
            let value = line.substring(line.indexOf(":") + 1)?.split("*")[0]?.trim()
            if (this.rawStrSplit[i]?.replaceAll(" ", "").length == 0) continue
            if (this.rawStrSplit[i]?.trim().charAt(0) == "/") {
                continue
            }
            else if (this.rawStrSplit[i].trim().charAt(0) == "@") {
                if (line.includes(":")) {
                    attrStr +=  key.replace("@", "") + "="
                    attrStr += "'" + value + "' "
                }
                else {
                    attrStr += key.replace("@", "") + " "
                }
            }
            else if (currAlr < attrAlt || !(/^[a-z]/.test(this.rawStrSplit[i].trim().charAt(0)))) {
                break
            }
            else {
                key = attributes.translate(key)
                styleVal += `${key}:${value.replaceAll("[", "var(--").replaceAll("]", ")")};`
            }
        }
    
        if (rawReponseBool) {
            return attrStr + (styleVal.length > 0 ? `style="${styleVal.replaceAll('"', "'")}"` : "")
        }
        else {
            return styleVal
        }
    }
    
    // Sends a close call for a wrapper structure
    sendClose(code) {
        let startAlr = this.rawStrSplit[this.currentLineIndex].match(/^\s*/)[0].length
        let insertIndex = this.rawStrSplit.length
        for (let i = this.currentLineIndex + 1; i < this.rawStrSplit.length; i++) {
            let currAlr = this.rawStrSplit[i].match(/^\s*/)[0].length
            if (currAlr <= startAlr && this.rawStrSplit[i].replaceAll(" ", "").length > 0) {
                insertIndex = i
                break
            } 
        }
        this.rawStrSplit.splice(insertIndex, 0, code)
        this.lineOffset += 1
    }

    // Structure Library
    structures = {
        build: {
            struct: (name, text = "", attr = "", type = "div")  => {
                this.html.push(liveStateCheck(`${type} ui="${name}" ${this.gatherAttributes(true)} ${attr}`, text))
                this.sendClose("/div")
            },
            inline: (name, attr = "", type = "div")  => {
                this.html.push(liveStateCheck(`${type} ui="${name}" ${this.gatherAttributes(true)} ${attr}`))
            },
            import: (content) => {
                this.html.push(`<div ${this.gatherAttributes(true)} import>`)
                this.html.push(content)
                this.sendClose("/div")
            },
            eachStack: (name)  => {
                let line = this.rawStrSplit[this.currentLineIndex]
                let valWorlSplit = line.split(":")[1].trim().split(" ")
                this.html.push(liveStateCheck(
                    `div ${this.gatherAttributes(true)} ui="${name}" each call="${valWorlSplit[0]}" nick="${valWorlSplit[2]}"`,
                    null
                ))
                this.sendClose("/div")
            },
        },
        // Declare Structure
        "Declare Structure": line => {
            let structName = line?.split("]")[1]?.trim()?.split(":")[0]
            let structInputs = line?.split(":")[1]?.trim()
            this.structures.build.struct(structName, null, `custom_struct inputs="${structInputs}"`)
            this.customStructs[structName] = {
                inputs: structInputs
            }
        },
        // Call Custom Structure
        "Custom Structure": line => { this.structures.build.struct(line?.trim(), null, "custom_struct_call") },
        // General Stacks
        "VStack": line => { this.structures.build.struct("v-stack") },
        "HStack": line => { this.structures.build.struct("h-stack") },
        "Grid": line => { this.structures.build.struct("grid") },
        // Each Stacks
        "GridEachStack": line => { this.structures.build.eachStack("grid") },
        "VEachStack": line => { this.structures.build.eachStack("v-stack") },
        "HEachStack": line => { this.structures.build.eachStack("h-stack") },
        // Imports
        "Import": line => {
            let filename = line?.split(":")[1]?.trim()
            let filecontent = fs.readFileSync(path.join(this.srcDir, `${filename}.vwi`), 'utf-8')
            new View(filecontent, resDOM => {
                this.structures.build.import(resDOM.html)
                this.endHtml.push(resDOM.endHtml)
                this.head.push(resDOM.head)
                this.js.push(resDOM.js)
                this.css.push(resDOM.css)
            }, this.srcDir)
        },
        "ImportJS": line => {
            let val = line.split(":")[1].trim()
            this.endHtml.push(`<script ${this.gatherAttributes(true)} src="${val}.js"></script>`)
        },
        "ImportJSURL": line => {
            let val = line.split(":")[1].trim()
            this.head.push(`<script ${this.gatherAttributes(true)} src="https://${val}"></script>`)
        },
        "ImportCSS": line => {
            let val = line.split(":")[1].trim()
            this.head.push(`<link rel="stylesheet" href="${val}.css">`)
        },
        "ImportCSSURL": line => {
            let val = line.split(":")[1].trim()
            this.head.push(`<link ref="stylesheet" ${this.gatherAttributes(true)} href="https://${val}">`)
        },
        "ImportFA": line => {
            this.head.push(`<script src="https://kit.fontawesome.com/5cf062dc93.js"></script>`)
        },
        // General HTML Elements
        "Image": line => {
            this.html.push(`<img ${this.gatherAttributes(true)} src='${line.split(":")[1].trim()}'>`)
        },
        // Blocks
        "Block": line => { this.structures.build.struct("block") },
        "Wrapper": line => { this.structures.build.struct("block") },
        "Element": line => { this.structures.build.struct("block") },
        // Text
        "Text": line => { this.structures.build.struct("text", line.substring(line.indexOf(":") + 1)?.trim()) },
        "Link": line => { this.structures.build.struct("link", line.substring(line.indexOf(":") + 1)?.trim(), null, "a") },
        "Button": line => { this.structures.build.struct("button", line.substring(line.indexOf(":") + 1)?.trim(), null ,"button") },
        "Span": line => { this.structures.build.struct("span", line.substring(line.indexOf(":") + 1)?.trim(), null, "span") },
        // Other HTML Elements
        "Audio": line => { this.structures.build.struct("audio", null, null, "audio") },
        "Input": line => { this.structures.build.inline("input", null, "input") },
        // HTML Meta Config
        "PageTitle": line => {
            const title = line.split(":")[1]?.trim();
            this.head.push(`
                <title>${title}</title>
                <meta name="apple-mobile-web-app-title" content="${title}">
                <meta name="application-name" content="${title}">
            `)
        },
        "PageIcon": line => { 
            let iconPath = line.split(":")[1]?.trim()
            this.head.push(`
                <link rel="apple-touch-icon" sizes="180x180" href="${iconPath}">
                <link rel="icon" type="image/png" sizes="32x32" href="${iconPath}">
                <link rel="icon" type="image/png" sizes="16x16" href="${iconPath}">
            `);
        },
    }
}

// Shorthand Attribute Dictionary
const attributes = {
    dictionary: {
        "align": "text-align",
        "size": "font-size",
        "weight": "font-weight",
        "spacing": "letter-spacing",
        "grid-row": "grid-template-rows",
        "grid-row-span": "grid-row",
        "grid-column": "grid-template-columns",
        "grid-column-span": "grid-column",
        "ratio": "aspect-ratio",
    },
    translate: (key) => {
        if (Object.keys(attributes.dictionary).includes(key)) {
            return attributes.dictionary[key]
        }
        else {
            return key
        }
    }
}

function liveStateCheck(elemWrapper = "div", elemContent = "") {
    let encodedWrapper = encodeHTML(elemWrapper);
    let encodedContent = encodeHTML(elemContent);
    let tagString = `live wrapper="${encodedWrapper}" content="${encodedContent}"`
    
    if (elemContent.includes("{") || elemContent.includes("{")) {
        return `<${elemWrapper} ${tagString}>`;
    }
    else if (elemWrapper.includes("{") || elemWrapper.includes("{")) {
        return `<${elemWrapper} ${tagString}>${elemContent}`;
    }
    else {
        return `<${elemWrapper}>${elemContent}`;
    }
}

let encodeHTMLElements = [
    ['"', '&dQuote'],
    ["'", "&sQuote"],
    ["(", "&oParen"],
    [")", "&cParen"],
    ["[", "&oBrack"],
    ["]", "&cBrack"],
    ["{", "&oBrace"],
    ["}", "&cBrace"],
    ["<", "&oHTML"],
    [">", "&cHTML"],
]
function encodeHTML(html) {
    encodeHTMLElements.forEach(charArr => {
        html = html?.replaceAll(charArr[0], charArr[1])
    })
    return html
}
function decodeHTML(html) {
    encodeHTMLElements.forEach(charArr => {
        html = html?.replaceAll(charArr[1], charArr[0])
    })
    return html
}

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import https from 'https';
import serveStatic from 'serve-static';
import { View, getBaseJS, getBaseHeadHTML, getBaseCSS } from './compiler.js';
import express from 'express';

const __filename = fileURLToPath(import.meta.url);
const __systemDir = path.dirname(__filename);
const __projectDir = path.join(__systemDir, "..")
const __publicDir = path.join(__projectDir, "public")
const __srcDir = path.join(__projectDir, "src")
const __port = 3000;

// HTTP Config
const privateKey = fs.readFileSync(path.join(__systemDir, 'https/key.pem'), 'utf-8');
const certificate = fs.readFileSync(path.join(__systemDir, 'https/cert.pem'), 'utf-8');
const credentials = { key: privateKey, cert: certificate };

// Version Control (Live Updates)
const __version = { version: Date.now() };

const app = express();

app.use(serveStatic(path.join(__projectDir, 'public')));

app.get('/version', (req, res) => res.json(__version));
app.get('/iosapp', (req, res) => res.send(__iosWebApp + "<iframe src='/' style='height:100vh;width:100vw;position:fixed;top:0;left:0;border:none;outline:none;' /> <style>body{margin:0;}</style>"));

app.get('/', (req, res) => openPage(req, res, path.join(__srcDir, "View.vwi")));

app.get('/:filename', (req, res) => processPageCall(req, res));

function processPageCall(req, res) {
    const filePath = req.params.filename;
    const routePath = path.join(__srcDir, filePath, 'View.vwi');
    openPage(req, res, routePath);
}

function openPage(req, res, routePath) {
    try {
        const fileContent = fs.readFileSync(routePath, 'utf-8');
        new View(fileContent, DOM => {
            res.send(`
                <head>${[getBaseHeadHTML(__systemDir), DOM.head].join("\n")}</head>
                <body>
                    ${DOM.html}
                    <style>${[getBaseCSS(__systemDir), DOM.css].join("\n")}</style>
                    <script>${[getBaseJS(__systemDir, true), DOM.js].join("\n")}</script>
                    ${DOM.endHtml}
                </body>
            `)
        }, __srcDir);
    } catch (error) {
        res.status(404).send('File not found' + getBaseJS(null, true) + "<style>body{background:black;color:white;}</style>");
    }
}

// Create HTTPS server
const httpsServer = https.createServer(credentials, app);

// Start the HTTPS server
httpsServer.listen(__port, () => {
    console.log('HTTPS Server running on https://localhost:' + __port);
});

import fs from 'fs';
import path from 'path';
import { View, getBaseJS, getBaseHeadHTML, getBaseCSS } from './compiler.js'
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __systemDir = path.dirname(__filename);
const __projectDir = path.join(__systemDir, "..")
const __publicDir = path.join(__projectDir, "public")
const __srcDir = path.join(__projectDir, "src")

const __outputDir = path.join(__projectDir, "docs")

// Copies files from srcDir to destDir
function copyFiles(src, dest) {
    fs.mkdirSync(dest, { recursive: true });
    const entries = fs.readdirSync(src, { withFileTypes: true });

    for (let entry of entries) {
        const srcPath = path.join(src, entry.name);
        const destPath = path.join(dest, entry.name);

        if (entry.isDirectory()) {
            copyFiles(srcPath, destPath)
        }
        else {
            fs.copyFileSync(srcPath, destPath)
        }
    }
}

// Finds View.vwi files and pushes to viewFiles
function findViewFiles(dir, basePath = "/") {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    const viewFiles = [];

    entries.forEach(entry => {
        const fullPath = path.join(dir, entry.name);

        if (entry.isDirectory()) {
            viewFiles.push(...findViewFiles(fullPath, basePath));
        } 
        else if (entry.name === 'View.vwi') {
            viewFiles.push({ fullPath: fullPath, relativePath: basePath });
        }
    })

    return viewFiles;
}


console.log("(*   ) Copying public files")

copyFiles(__publicDir, __outputDir);
const viewFiles = findViewFiles(__srcDir);

console.log(`(**  ) Compiling ${viewFiles.length} view file${viewFiles.length > 1 ? "s" : ""}`)

viewFiles.forEach(file => {
    const fileContent = fs.readFileSync(file.fullPath, 'utf-8');
    new View(fileContent, DOM => {
        const head = [getBaseHeadHTML(__systemDir), DOM.head].join("\n");
        const style = "<style>" + [getBaseCSS(__systemDir), DOM.css].join("\n") + "</style>"
        const script = "<script>" + [getBaseJS(__systemDir), DOM.js].join("\n") + "</script>";
        const htmlFileContent = head + DOM.html + style + script + DOM.endHtml
        const htmlFilePath = path.join(__outputDir, file.relativePath, "index.html")
        fs.mkdirSync(file.relativePath, { recursive: true });
        fs.writeFileSync(htmlFilePath, htmlFileContent, 'utf-8');
    }, __srcDir);
})

console.log("(*** ) Finished compiling")
console.log("(****) Build complete! \n")

let currentVersion = null;
function checkForUpdate() {
	fetch('/version')
		.then(response => response.json())
		.then(data => {
			if (currentVersion === null) {
				currentVersion = data.version;
				console.log("On version: " + data.version)
			} 
			else if (data.version !== currentVersion) {
				location.reload();
			}
		})
		.catch(err => console.error('Error checking for update:', err));
}
setInterval(checkForUpdate, 500);



window.addEventListener("DOMContentLoaded", () => {
    processCustomStructs()
    liveState.process()
    updateState()
})

function updateState() {
    liveState.updateAttr()
    liveState.updateText()
    buildEachStacks()
    buildCustomStructs()
}


let live_state = []
const liveState = {
    process: () => {
        document.querySelectorAll(`[live]`).forEach((elem, index) => {
            elem.setAttribute("live_id", index);
            let attributes = [];
            Array.from(elem.attributes).forEach(attr => {
                attributes.push([attr.name, attr.value]);
            });
    
            live_state[index] = {
                wrapper: elem.getAttribute("wrapper"),
                content: elem.getAttribute("content"),
                attributes: attributes
            };
        })
    },
    updateAttr: () => {
        document.querySelectorAll(`[live]`).forEach(elem => {
            let liveId = elem.getAttribute('live_id');
            let target = live_state[liveId];

            let excluded_attr = ["wrapper", "content", "live", "live_id"]
            let rawAttr = target.attributes.filter(attr => !excluded_attr.includes(attr[0]));
            let copyAttr = rawAttr.map(attr => [...attr])
            copyAttr.forEach(attrPair => {
                attrPair[0] = evalString(decodeHTML(attrPair[0]))
                attrPair[1] = evalString(decodeHTML(attrPair[1]))
                elem.setAttribute(attrPair[0], attrPair[1])
            })
        })
    },
    updateText: () => {
        document.querySelectorAll(`[live]`).forEach(elem => {
            let liveId = elem.getAttribute('live_id');
            let target = live_state[liveId];
            
            let rawContent = decodeHTML(target.content)
            if (rawContent.includes("{") || rawContent.includes("}")) {
                elem.innerHTML = evalString(rawContent)
            }
        })
    }
}

let each_stacks = []
function buildEachStacks() {
    document.querySelectorAll(`[each]`).forEach(elem => {
        let contents = []
        if (!elem.getAttribute("storage_index")) {
            let obj_html = elem.innerHTML
            let obj = {
                call: elem.getAttribute("call"),
                html: obj_html,
                evals: extractEvalStrings(obj_html)
            }
            elem.setAttribute("storage_index", each_stacks.length)
            elem.style.display = "none"
            each_stacks.push(obj)
        }
        let obj = each_stacks[elem.getAttribute("storage_index")]
        try {
            let call = eval(obj.call)
            let html = obj.html
            for (let i = 0; i < call.length; i++) {
                let itemHTML = html
                let evalCalls = new Set(obj.evals)
                evalCalls.forEach(evalCall => {
                    let call = elem.getAttribute("call")
                    let nick = elem.getAttribute("nick")
                    itemHTML = itemHTML.replaceAll(nick, call + `[${i}]`)
                })
                contents.push(evalString(itemHTML))
            }
        }
        catch (error) {  }
        elem.innerHTML = contents.join("\n")
        elem.style = ""
    })
}

let custom_structs = []
function processCustomStructs() {
    document.querySelectorAll(`[custom_struct]`).forEach(elem => {
        custom_structs.push({
            elem: elem,
            name: elem.getAttribute("ui"),
            inputs: elem.getAttribute("inputs"),
            content: elem.innerHTML,
        })
    })
} 
function buildCustomStructs() {
    document.querySelectorAll(`[custom_struct_call]`).forEach(elem => {
        let struct = custom_structs.find(struct => struct.name == elem.getAttribute("ui"))
        let inputs = struct?.inputs ? struct.inputs.split(",") : []
        let content = struct?.content
        inputs.forEach(input => {
            input = input?.trim()
            content = content.replaceAll(`$${input}`, elem.getAttribute(input))
        })
        elem.innerHTML = content
    })
}

function evalString(string) {
    if (string.includes("{") && string.includes("}")) {
        let callCount = string.split("{").length - 1;
        
        for (let i = 0; i < callCount; i++) {
            let openIndex = string.indexOf("{");
            let closeIndex = string.indexOf("}");
            let evalString = string.substring(openIndex + 1, closeIndex);

            try {
                let evaluatedValue = eval(evalString);
                string = string.replace(`{${evalString}}`, evaluatedValue);
            } catch (error) {
            }
        }
    }
    return string;
}

function extractEvalStrings(string) {
    let res = string
    let strings = []
    let layers = 0
    if (res.includes("{")) {
        let callCount = res.split("{").length - 1
        for (let i = 0; i < callCount; i ++) {
            let index = res.indexOf("{")
            let evalStr = ""
            for (let j = index + 1; j < res.length; j++) {
                if (res.charAt(j) == "{") {
                    layers++
                }
                else if (res.charAt(j) == "}") {
                    if (layers > 0) {
                        layers--
                        i++
                    }
                    else {
                        break
                    }
                }
                evalStr += res.charAt(j)
            }
            strings.push(evalStr)
        }
    }
    return strings
}

function Icon(icon) {
    return "<i class='fa-solid fa-" + icon + "'></i>"
    // <i class="fa-solid fa-arrow-left"></i>
}

let encodeHTMLElements = [
    ['"', '&dQuote'],
    ["'", "&sQuote"],
    ["(", "&oParen"],
    [")", "&cParen"],
    ["[", "&oBrack"],
    ["]", "&cBrack"],
    ["{", "&oBrace"],
    ["}", "&cBrace"],
    ["<", "&oHTML"],
    [">", "&cHTML"],
]
function encodeHTML(html) {
    encodeHTMLElements.forEach(charArr => {
        html = html?.replaceAll(charArr[0], charArr[1])
    })
    return html
}
function decodeHTML(html) {
    encodeHTMLElements.forEach(charArr => {
        html = html?.replaceAll(charArr[1], charArr[0])
    })
    return html
}

const store = {
    key: "song",
    get: key => {
        let storageString = localStorage.getItem("storage_" + store.key) ? localStorage.getItem("storage_" + store.key) : "{}"
        let val = ""
        try {
            let json = JSON.parse(storageString)
            val = json[key]
        } 
        catch (error) { 
            console.error(error)
        }
        if (val !== undefined) {
            return val
        }
        else {
            return null
        }
    },
    set: (key, val, cb) => {
        let storageString = localStorage.getItem("storage_" + store.key) ? localStorage.getItem("storage_" + store.key) : "{}"
        try {
            let json = JSON.parse(storageString)
            json[key] = val
            localStorage.setItem("storage_" + store.key, JSON.stringify(json))
        } catch (error) { 
            return false
        }
        if (cb) cb()
        try {
            updateState()
            console.log("Store Updated")
        }
        catch (error) { }
    },
    safety: (key, val) => {
        let res = store.get(key)
        if (!res) {
            store.set(key, val)
        }
    }
}